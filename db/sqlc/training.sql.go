// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: training.sql

package db

import (
	"context"
	"time"
)

const createTraining = `-- name: CreateTraining :one
INSERT INTO trainings (
date_and_time, place
) VALUES (
$1, $2
)
RETURNING training_id, place, type, date_and_time, price, trainer
`

type CreateTrainingParams struct {
	DateAndTime time.Time `json:"date_and_time"`
	Place       string    `json:"place"`
}

func (q *Queries) CreateTraining(ctx context.Context, arg CreateTrainingParams) (Training, error) {
	row := q.db.QueryRowContext(ctx, createTraining, arg.DateAndTime, arg.Place)
	var i Training
	err := row.Scan(
		&i.TrainingID,
		&i.Place,
		&i.Type,
		&i.DateAndTime,
		&i.Price,
		&i.Trainer,
	)
	return i, err
}

const deleteTraining = `-- name: DeleteTraining :exec
DELETE FROM trainings WHERE training_id = $1
`

func (q *Queries) DeleteTraining(ctx context.Context, trainingID int64) error {
	_, err := q.db.ExecContext(ctx, deleteTraining, trainingID)
	return err
}

const getTraining = `-- name: GetTraining :one
SELECT training_id, place, type, date_and_time, price, trainer FROM trainings
WHERE training_id = $1 LIMIT 1
`

func (q *Queries) GetTraining(ctx context.Context, trainingID int64) (Training, error) {
	row := q.db.QueryRowContext(ctx, getTraining, trainingID)
	var i Training
	err := row.Scan(
		&i.TrainingID,
		&i.Place,
		&i.Type,
		&i.DateAndTime,
		&i.Price,
		&i.Trainer,
	)
	return i, err
}

const listLastWeekTrainings = `-- name: ListLastWeekTrainings :many
SELECT training_id, place, type, date_and_time, price, trainer FROM trainings
WHERE date_and_time > now() - INTERVAL '7' DAY
ORDER BY date_and_time
`

func (q *Queries) ListLastWeekTrainings(ctx context.Context) ([]Training, error) {
	rows, err := q.db.QueryContext(ctx, listLastWeekTrainings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Training{}
	for rows.Next() {
		var i Training
		if err := rows.Scan(
			&i.TrainingID,
			&i.Place,
			&i.Type,
			&i.DateAndTime,
			&i.Price,
			&i.Trainer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrainings = `-- name: ListTrainings :many
SELECT training_id, place, type, date_and_time, price, trainer FROM trainings
WHERE date_and_time > now()
ORDER BY date_and_time
`

func (q *Queries) ListTrainings(ctx context.Context) ([]Training, error) {
	rows, err := q.db.QueryContext(ctx, listTrainings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Training{}
	for rows.Next() {
		var i Training
		if err := rows.Scan(
			&i.TrainingID,
			&i.Place,
			&i.Type,
			&i.DateAndTime,
			&i.Price,
			&i.Trainer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrainingsForSend = `-- name: ListTrainingsForSend :many
SELECT trainings.training_id, place, date_and_time, COALESCE (U.appointment_id, 0) AS appointment_id 
FROM trainings
LEFT JOIN (SELECT appointment_id, training_id, user_id, created_at FROM appointments WHERE user_id=$1) AS U
ON trainings.training_id = U.training_id
WHERE date_and_time > now()
ORDER BY date_and_time
`

type ListTrainingsForSendRow struct {
	TrainingID    int64     `json:"training_id"`
	Place         string    `json:"place"`
	DateAndTime   time.Time `json:"date_and_time"`
	AppointmentID int64     `json:"appointment_id"`
}

func (q *Queries) ListTrainingsForSend(ctx context.Context, userID int64) ([]ListTrainingsForSendRow, error) {
	rows, err := q.db.QueryContext(ctx, listTrainingsForSend, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTrainingsForSendRow{}
	for rows.Next() {
		var i ListTrainingsForSendRow
		if err := rows.Scan(
			&i.TrainingID,
			&i.Place,
			&i.DateAndTime,
			&i.AppointmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTraining = `-- name: UpdateTraining :one
UPDATE trainings SET trainer = $2
WHERE training_id = $1
RETURNING training_id, place, type, date_and_time, price, trainer
`

type UpdateTrainingParams struct {
	TrainingID int64  `json:"training_id"`
	Trainer    string `json:"trainer"`
}

func (q *Queries) UpdateTraining(ctx context.Context, arg UpdateTrainingParams) (Training, error) {
	row := q.db.QueryRowContext(ctx, updateTraining, arg.TrainingID, arg.Trainer)
	var i Training
	err := row.Scan(
		&i.TrainingID,
		&i.Place,
		&i.Type,
		&i.DateAndTime,
		&i.Price,
		&i.Trainer,
	)
	return i, err
}

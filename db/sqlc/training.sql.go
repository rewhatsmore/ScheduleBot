// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: training.sql

package db

import (
	"context"
	"time"
)

const createTraining = `-- name: CreateTraining :one
INSERT INTO trainings (
date_and_time, group_type, column_number
) VALUES (
$1, $2, $3
)
RETURNING training_id, place, type, date_and_time, price, trainer, group_type, column_number
`

type CreateTrainingParams struct {
	DateAndTime  time.Time     `json:"date_and_time"`
	GroupType    GroupTypeEnum `json:"group_type"`
	ColumnNumber int64         `json:"column_number"`
}

func (q *Queries) CreateTraining(ctx context.Context, arg CreateTrainingParams) (Training, error) {
	row := q.db.QueryRowContext(ctx, createTraining, arg.DateAndTime, arg.GroupType, arg.ColumnNumber)
	var i Training
	err := row.Scan(
		&i.TrainingID,
		&i.Place,
		&i.Type,
		&i.DateAndTime,
		&i.Price,
		&i.Trainer,
		&i.GroupType,
		&i.ColumnNumber,
	)
	return i, err
}

const deleteTraining = `-- name: DeleteTraining :exec

DELETE FROM trainings WHERE training_id = $1
`

// -- name: UpdateTraining :one
// UPDATE trainings SET trainer = $2
// WHERE training_id = $1
// RETURNING *;
func (q *Queries) DeleteTraining(ctx context.Context, trainingID int64) error {
	_, err := q.db.ExecContext(ctx, deleteTraining, trainingID)
	return err
}

const getTraining = `-- name: GetTraining :one
SELECT training_id, place, type, date_and_time, price, trainer, group_type, column_number FROM trainings
WHERE training_id = $1 LIMIT 1
`

func (q *Queries) GetTraining(ctx context.Context, trainingID int64) (Training, error) {
	row := q.db.QueryRowContext(ctx, getTraining, trainingID)
	var i Training
	err := row.Scan(
		&i.TrainingID,
		&i.Place,
		&i.Type,
		&i.DateAndTime,
		&i.Price,
		&i.Trainer,
		&i.GroupType,
		&i.ColumnNumber,
	)
	return i, err
}

const listAdultTrainings = `-- name: ListAdultTrainings :many
SELECT training_id, place, type, date_and_time, price, trainer, group_type, column_number FROM trainings
WHERE date_and_time >= date_trunc('week', now()) 
  AND date_and_time < date_trunc('week', now()) + INTERVAL '2 weeks'
  AND group_type = 'adult'
ORDER BY date_and_time
`

func (q *Queries) ListAdultTrainings(ctx context.Context) ([]Training, error) {
	rows, err := q.db.QueryContext(ctx, listAdultTrainings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Training{}
	for rows.Next() {
		var i Training
		if err := rows.Scan(
			&i.TrainingID,
			&i.Place,
			&i.Type,
			&i.DateAndTime,
			&i.Price,
			&i.Trainer,
			&i.GroupType,
			&i.ColumnNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChildrenTrainings = `-- name: ListChildrenTrainings :many
SELECT training_id, place, type, date_and_time, price, trainer, group_type, column_number FROM trainings
WHERE date_and_time >= date_trunc('week', now()) 
  AND date_and_time < date_trunc('week', now()) + INTERVAL '2 weeks'
AND group_type = 'child'
ORDER BY date_and_time
`

func (q *Queries) ListChildrenTrainings(ctx context.Context) ([]Training, error) {
	rows, err := q.db.QueryContext(ctx, listChildrenTrainings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Training{}
	for rows.Next() {
		var i Training
		if err := rows.Scan(
			&i.TrainingID,
			&i.Place,
			&i.Type,
			&i.DateAndTime,
			&i.Price,
			&i.Trainer,
			&i.GroupType,
			&i.ColumnNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLastWeekTrainings = `-- name: ListLastWeekTrainings :many
SELECT training_id, place, type, date_and_time, price, trainer, group_type, column_number FROM trainings
WHERE date_and_time > now() - INTERVAL '7' DAY
ORDER BY date_and_time
`

func (q *Queries) ListLastWeekTrainings(ctx context.Context) ([]Training, error) {
	rows, err := q.db.QueryContext(ctx, listLastWeekTrainings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Training{}
	for rows.Next() {
		var i Training
		if err := rows.Scan(
			&i.TrainingID,
			&i.Place,
			&i.Type,
			&i.DateAndTime,
			&i.Price,
			&i.Trainer,
			&i.GroupType,
			&i.ColumnNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrainings = `-- name: ListTrainings :many
SELECT training_id, place, type, date_and_time, price, trainer, group_type, column_number FROM trainings
WHERE date_and_time > now()
ORDER BY date_and_time
`

func (q *Queries) ListTrainings(ctx context.Context) ([]Training, error) {
	rows, err := q.db.QueryContext(ctx, listTrainings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Training{}
	for rows.Next() {
		var i Training
		if err := rows.Scan(
			&i.TrainingID,
			&i.Place,
			&i.Type,
			&i.DateAndTime,
			&i.Price,
			&i.Trainer,
			&i.GroupType,
			&i.ColumnNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrainingsForSend = `-- name: ListTrainingsForSend :many
SELECT 
  trainings.training_id, 
  date_and_time, 
  column_number, 
  COALESCE(U.appointment_id, 0) AS appointment_id, 
  COALESCE(additional_child_number, -1) AS additional_child_number,
  (SELECT COUNT(*) FROM appointments WHERE training_id = trainings.training_id) AS appointment_count
FROM trainings
LEFT JOIN (SELECT appointment_id, training_id, user_id, additional_child_number, created_at FROM appointments A WHERE A.user_id=$1) AS U
ON trainings.training_id = U.training_id
WHERE date_and_time > now() + INTERVAL '5 hours' AND group_type = $2
ORDER BY date_and_time
`

type ListTrainingsForSendParams struct {
	UserID    int64         `json:"user_id"`
	GroupType GroupTypeEnum `json:"group_type"`
}

type ListTrainingsForSendRow struct {
	TrainingID            int64     `json:"training_id"`
	DateAndTime           time.Time `json:"date_and_time"`
	ColumnNumber          int64     `json:"column_number"`
	AppointmentID         int64     `json:"appointment_id"`
	AdditionalChildNumber int64     `json:"additional_child_number"`
	AppointmentCount      int64     `json:"appointment_count"`
}

func (q *Queries) ListTrainingsForSend(ctx context.Context, arg ListTrainingsForSendParams) ([]ListTrainingsForSendRow, error) {
	rows, err := q.db.QueryContext(ctx, listTrainingsForSend, arg.UserID, arg.GroupType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTrainingsForSendRow{}
	for rows.Next() {
		var i ListTrainingsForSendRow
		if err := rows.Scan(
			&i.TrainingID,
			&i.DateAndTime,
			&i.ColumnNumber,
			&i.AppointmentID,
			&i.AdditionalChildNumber,
			&i.AppointmentCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

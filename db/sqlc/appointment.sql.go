// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: appointment.sql

package db

import (
	"context"
	"time"
)

const createAppointment = `-- name: CreateAppointment :one
INSERT INTO appointments (
training_id, internal_user_id, additional_child_number
) VALUES (
$1, $2, $3
) ON CONFLICT (training_id, internal_user_id)
DO UPDATE SET additional_child_number = EXCLUDED.additional_child_number
RETURNING appointment_id, training_id, internal_user_id, additional_child_number, created_at
`

type CreateAppointmentParams struct {
	TrainingID            int64 `json:"training_id"`
	InternalUserID        int64 `json:"internal_user_id"`
	AdditionalChildNumber int64 `json:"additional_child_number"`
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRowContext(ctx, createAppointment, arg.TrainingID, arg.InternalUserID, arg.AdditionalChildNumber)
	var i Appointment
	err := row.Scan(
		&i.AppointmentID,
		&i.TrainingID,
		&i.InternalUserID,
		&i.AdditionalChildNumber,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAppointment = `-- name: DeleteAppointment :exec
DELETE FROM appointments WHERE appointment_id = $1
`

func (q *Queries) DeleteAppointment(ctx context.Context, appointmentID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAppointment, appointmentID)
	return err
}

const getAppointment = `-- name: GetAppointment :one
SELECT appointment_id, training_id, internal_user_id, additional_child_number, created_at FROM appointments
WHERE appointment_id = $1 LIMIT 1
`

func (q *Queries) GetAppointment(ctx context.Context, appointmentID int64) (Appointment, error) {
	row := q.db.QueryRowContext(ctx, getAppointment, appointmentID)
	var i Appointment
	err := row.Scan(
		&i.AppointmentID,
		&i.TrainingID,
		&i.InternalUserID,
		&i.AdditionalChildNumber,
		&i.CreatedAt,
	)
	return i, err
}

const getAppointmentCount = `-- name: GetAppointmentCount :one
SELECT COUNT(*) FROM appointments
WHERE training_id = $1
`

func (q *Queries) GetAppointmentCount(ctx context.Context, trainingID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAppointmentCount, trainingID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listTrainingUsers = `-- name: ListTrainingUsers :many
SELECT appointment_id, training_id, appointments.internal_user_id, telegram_user_id, full_name, additional_child_number, appointments.created_at FROM appointments
JOIN users ON appointments.internal_user_id=users.internal_user_id
WHERE training_id = $1
ORDER BY appointments.created_at
`

type ListTrainingUsersRow struct {
	AppointmentID         int64     `json:"appointment_id"`
	TrainingID            int64     `json:"training_id"`
	InternalUserID        int64     `json:"internal_user_id"`
	TelegramUserID        int64     `json:"telegram_user_id"`
	FullName              string    `json:"full_name"`
	AdditionalChildNumber int64     `json:"additional_child_number"`
	CreatedAt             time.Time `json:"created_at"`
}

func (q *Queries) ListTrainingUsers(ctx context.Context, trainingID int64) ([]ListTrainingUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listTrainingUsers, trainingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTrainingUsersRow{}
	for rows.Next() {
		var i ListTrainingUsersRow
		if err := rows.Scan(
			&i.AppointmentID,
			&i.TrainingID,
			&i.InternalUserID,
			&i.TelegramUserID,
			&i.FullName,
			&i.AdditionalChildNumber,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTrainings = `-- name: ListUserTrainings :many
SELECT appointment_id, appointments.training_id, additional_child_number, users.telegram_user_id, type, date_and_time, price, trainer  FROM appointments
JOIN trainings ON appointments.training_id=trainings.training_id
JOIN users ON appointments.internal_user_id=users.internal_user_id
WHERE telegram_user_id = $1 AND date_and_time > now()
ORDER BY date_and_time
`

type ListUserTrainingsRow struct {
	AppointmentID         int64     `json:"appointment_id"`
	TrainingID            int64     `json:"training_id"`
	AdditionalChildNumber int64     `json:"additional_child_number"`
	TelegramUserID        int64     `json:"telegram_user_id"`
	Type                  string    `json:"type"`
	DateAndTime           time.Time `json:"date_and_time"`
	Price                 int64     `json:"price"`
	Trainer               string    `json:"trainer"`
}

func (q *Queries) ListUserTrainings(ctx context.Context, telegramUserID int64) ([]ListUserTrainingsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserTrainings, telegramUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserTrainingsRow{}
	for rows.Next() {
		var i ListUserTrainingsRow
		if err := rows.Scan(
			&i.AppointmentID,
			&i.TrainingID,
			&i.AdditionalChildNumber,
			&i.TelegramUserID,
			&i.Type,
			&i.DateAndTime,
			&i.Price,
			&i.Trainer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersForAlert = `-- name: ListUsersForAlert :many
SELECT appointments.internal_user_id, telegram_user_id, date_and_time FROM appointments
JOIN trainings ON appointments.training_id=trainings.training_id
JOIN users ON appointments.internal_user_id=users.internal_user_id
WHERE users.telegram_user_id IS NOT NULL AND date_part('day', date_and_time)  = date_part('day', now() + INTERVAL '1' DAY) AND date_and_time > now()
`

type ListUsersForAlertRow struct {
	InternalUserID int64     `json:"internal_user_id"`
	TelegramUserID int64     `json:"telegram_user_id"`
	DateAndTime    time.Time `json:"date_and_time"`
}

func (q *Queries) ListUsersForAlert(ctx context.Context) ([]ListUsersForAlertRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersForAlert)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersForAlertRow{}
	for rows.Next() {
		var i ListUsersForAlertRow
		if err := rows.Scan(&i.InternalUserID, &i.TelegramUserID, &i.DateAndTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
